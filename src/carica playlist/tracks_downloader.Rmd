---
title: "R Notebook"
output: html_notebook
---

# Import libraries
```{r}
# install.packages('pacman')
library(pacman)
pacman::p_load('spotifyr',  # To access the API
               'tidyverse', # Data wrangling and plots
               'plotly',    # Interactive plots
               'ggimage',   # Adding album covers to ggplot
               'kableExtra',# Format tables
               'httpuv',    # To be able to access the Spotify URL
               'httr')      # In case you want to access the API w/o
                            # the package

library(spotifyr)
library(dplyr )
```

# Get access
```{r}
CLIENT_ID='e862d6e00b244fe090bcb7bd0edd2fc8'
CLIENT_SECRET='d00ce12e600741ad8b614769eb52b7b8'

Sys.setenv(SPOTIFY_CLIENT_ID = CLIENT_ID)
Sys.setenv(SPOTIFY_CLIENT_SECRET = CLIENT_SECRET)

access_token <- get_spotify_access_token(
  client_id = Sys.getenv("SPOTIFY_CLIENT_ID"),
  client_secret = Sys.getenv("SPOTIFY_CLIENT_SECRET")
)
```

# LOAD DATA
```{r}
questionare <- read.csv("../../data/Questionario Spotify (Risposte) - Risposte del modulo 1.csv")

questionare=questionare[3:dim(questionare)[1],]  #la prima riga è vuota e la seconda ha un link non valido
lista_stringhe=questionare[,2]
valori_non_http <- which(!grepl("^http", lista_stringhe))

questionare = questionare[-valori_non_http,]


link_playlists = questionare[,"Incolla.qua.il.link"]
```

# manual corrections
```{r}
link_playlists[5]="https://open.spotify.com/playlist/37i9dQZF1F0sijgNaJdgit?si=ySYezdR1SrWx3Edh2_Gwzg"
```


## debug
```{r}
#link_playlists
link_playlists = link_playlists[1:3]
```
# add_advanced_features

questa funzione utilizza l'id del brano, che quindi non richiede l'accesso alla playlista, basta che track.id venga salvato
ergo questa funzione può essere utilizzata anche in futuro
```{r}
add_advanced_features <- function(data){
  ids = data$track.id

  adv_features = get_track_audio_analysis(ids[1])
  print(names(adv_features))
  print(data.frame(adv_features$segments))
}

```


# Function to extract tracks features

Note codice
".*/(.+)$"
è un'espressione regolare che corrisponde a una stringa che inizia con qualsiasi carattere (.*) seguito da una barra (/), e cattura quindi uno o più caratteri (.+) fino alla fine della stringa ($). Questo effettivamente cattura l'ultima parte di una stringa che segue l'ultima barra.


```{r}
extract_tracks <- function(spot_link){
  # Use regular expression to extract the identifier
  spot_link <- sub(".*/(.+)$", "\\1", spot_link)
  
  tracks <- get_playlist_audio_features(playlist_uris = spot_link)
  features=c(
            "track.name" ,
            "track.album.name",
            "track.album.artists",
            "track.album.release_date",
            "track.popularity",
            "acousticness", #
            "danceability", #
            "energy", #
            "instrumentalness", #
            "liveness", #
            "loudness", #
            "speechiness", #
            "tempo", #
            "key", ##
            "mode", ##
            "track.duration_ms" ,##
            "valence",##
            "time_signature", #
            "track.id"  # used to add the tracks to another playlists
  
            )
  
  
  data = tracks[features]
  # add_advanced_features(data)
  
  
  for(i in 1:dim(data)[1]){
    data[i,"artists"] = data[i,"track.album.artists"][[1]][[1]][3][1,]
    genres = get_artist(data[i,"track.album.artists"][[1]][[1]][[2]][1])$genres
    if(length(genres)!=0){
        for(j in 1:length(genres)){
           data[i,paste0("genre_",j)] = genres[j]
        }
    }
  }
  data$track.album.artists = NULL

  # move the artists column at the beginning
  data=data %>% relocate(artists, .after = track.name)
  return(data)
}
```

# funzioni ausiari per ottimizzare

per evitare di scaricare più volte gli stessi dati faccio un controllo nella cartella in cui sono stati salvati
```{r}
already_done <- function(name_id){
  name_file = paste0(name_id,".csv")
  # Imposta il percorso della cartella
  
  cartella <- "../../data/tracks_info_3/"

  # Ottieni la lista dei file nella cartella
  lista_file <- list.files(path = cartella, full.names = TRUE)
    
  
  taglia_percorso <- function(elemento) {
    return(sub(".*/(.+)$", "\\1", elemento))
  }
  

  # Applica la funzione a ogni elemento della lista
  lista_file <- lapply(lista_file, taglia_percorso)


  
  # Stampa la lista dei file
  return (name_file %in% lista_file)
}
```



# create dataframe list

```{r}
data_tracks = list()
id_non_validi <- list()
counter = 1

for (url in link_playlists) {

  name_id = sub(".*/(.+)$", "\\1", url)
  name_id = substr(name_id, start = 1, stop = 15)
  
  # if the user has already been analysed it skips
  if(!already_done(name_id)){
      tryCatch({
        data_tracks[[name_id]] <- extract_tracks(url)
      }, error = function(e) {
        # Se si verifica un errore, salva l'id non valido
        id_non_validi <- c(id_non_validi, name_id)
        cat("Errore nell'elaborazione dell'ID:", name_id, "\n")
      })
      
      if(counter%%2==0){  # every 2 playlists(200 songs) stops for 50 seconds
      Sys.sleep(35)
      }
      
  }
    # show progression
    print(counter)
    counter=counter+1

}

id_non_validi
```


# Save data 

data of tracks will be saved separetly on csv files named with the link of the spotify playlist (only first 15 chars)
```{r}
for (i in seq_along(data_tracks)) {
  name = names(data_tracks)[i]
  write.csv(data_tracks[[i]], paste0("../../data/tracks_info_3/",name , ".csv"), row.names = FALSE)
}
```

# EXTRA

## UTILS, prove codice

```{r}
data = extract_tracks(link_playlists[1])
```


# IGNORE

```{r}
file_name = "data_tracks"
file_name = paste0(file_name,".csv")

write.csv(data_tracks, file =paste0("../../data/",file_name), row.names = FALSE)
```
```{r}
# Store the data in a dataframe
EVERYTHING = "3EbHbn5D6oNFLJ5FrQKcAj?si=6ab30cd7e6794754"
ALTERNATIVE="39VgCTxGok4VIgIycgyTRq?si=f0ee9b71e9f048b2"
SHORT = "6zSzzHtzQxXVf9kuQXO3eS?si=7917643ebd854a5c"
AMICA_ALE = "0fCgMTSTRKPWUKp11pYQ6F?si=165f512ebe7b4a59"
ETTORE22 = "05oN1p78ynHAs0ulg4HvuF?si=069dd1d8a82b4d1e"




tracks <- get_playlist_audio_features(playlist_uris = ETTORE22)
head(tracks[,36])
dim(tracks)[1]
```



